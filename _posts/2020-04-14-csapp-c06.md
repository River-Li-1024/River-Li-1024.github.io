---
layout: post
title: 笔记：<深入理解计算机系统>-C06.存储器层次结构
categories: 技术笔记
description: 存储器层次结构
keywords: 操作系统,csapp
---

<a name="4570"/>

<div>
<span><div><div><br/></div><div><span style="font-weight: bold; font-size: 12pt;">存储器系统 Memory System</span></div><div>1.具有不同容量、成本和访问时间的存储设备层次结构；</div><div>2.整体效果：一个大的存储器池，成本与层次底层最便宜设备相当，性能接近于顶层存储设备；</div><div>3.利用局部性原理：locality</div><div><br/></div><hr/><div><span style="font-weight: bold; font-size: 12pt;">存储设备技术</span></div><div><span style="font-weight: bold;">1.随机访问存储器</span> Random-Access Memory   RAM，分为静态SRAM 和动态DRAM</div><div><img src="/images/posts/csapp-c06/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">2.静态RAM</span></div><div>每个位存储在一个双稳态的存储器单元里，用一个六晶体管电路来实现；</div><div>只要有电就能保持稳定状态，即使被干扰，一旦消除也能自动恢复到稳定态；</div><div><br/></div><div><span style="font-weight: bold;">3.动态RAM</span></div><div>每个位存储为对一个电容的充电，外加一个访问晶体管；</div><div>对干扰非常敏感，被扰乱后无法恢复；</div><div>容易漏电，所以需要计算机以时钟频率周期性地读出/重写刷新每一位；</div><div><br/></div><div><span style="font-weight: bold;">4.传统的DRAM芯片的实现</span></div><div><img src="/images/posts/csapp-c06/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>内存控制器电路先后发送i/j地址，分别称为RAS/CAS；=&gt; 组织成二位整列，并分两次传送可降低地址引脚的数量</div><div>将整行复制到内部行缓冲区中，再复制到超单元中，通过数据引脚输出；</div><div><br/></div><div><span style="font-weight: bold;">5.DRAM芯片封装在内存模块中</span></div><div><img src="/images/posts/csapp-c06/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>从一个内存模块中读取数据，分8个芯片，各自读取8个字节，组合成最终64位的数据；</div><div>将多个内存模块连接到内存控制器，可聚合合成主存；</div><div><br/></div><div><span style="font-weight: bold;">6.增强的DRAM</span></div><div>Fast Page Mode DRAM：快页模式DRAM =&gt; 多次从内部行缓冲区中获取数据</div><div>Extended Data Out DRAM：</div><div>Synchronous DRAM：同步DRAM   SDRAM =&gt; 与内存控制器使用相同的外部时钟信号；</div><div>Double Data-Rate Synchronous DRAM：双倍数据速率同步DRAM DDR SDRAM =&gt; 使用两个时钟沿作为控制信号</div><div><br/></div><div><span style="font-weight: bold;">7.非易失性存储器  / 只读存储器ROM</span></div><div>PROM：Programmable ROM，只可被编程一次，高电流熔断一次</div><div>EPROM：Erasable Programmable ROM，可擦写可编程，1000次，写入需要特殊设备</div><div>EEPROM：Electrically Erasable PROM，电子可擦除，10^5次，直接在印制电路上编程；</div><div>Flash Memory：基于EEPROM</div><div>SSD：Solid State Disk，固态硬盘</div><div><br/></div><div>Firmware：固件，存储在ROM设备中的程序，通电后执行</div><div><br/></div><div><span style="font-weight: bold;">8.CPU和DRAM通信 =&gt; 访问主存</span></div><div><img src="/images/posts/csapp-c06/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>总线Bus：一组并行导线，能携带地址、数据和控制信号；</div><div>IO桥：翻译系统总线和内存总线的电子信号</div><div>总线接口：发起读写事务的电路</div><div><br/></div><div><span style="font-weight: bold;">9.磁盘存储</span></div><div>磁盘由盘片（platter）构成，两个面称为表面（surface），中央有个可旋转的主轴（spindle）</div><div>每分钟旋转速度RPM（Revolution Per Minute）</div><div>每个表面由一组磁道（track）组成，每个磁道划分成一组扇区（sector），每个扇区包含包含同等数量的数据位（512字节）</div><div>整个磁盘装置称为磁盘驱动器（disk drive）</div><div><img src="/images/posts/csapp-c06/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><img src="/images/posts/csapp-c06/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">10.磁盘操作</span></div><div>磁盘以扇区大小的块来读写数据，对扇区的访问时间有三个主要的部分</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">寻道时间 seek time：依赖于传动臂在盘面上的移动速度，通常为3-9ms</font></div><div><font face="Monaco">旋转时间 rotational latency：依赖于磁盘的旋转速度</font></div><div><font face="Monaco">传送时间 transfer time：依赖于旋转速度和每条磁道的扇区数目</font></div></div><div>访问一个扇区的时间主要是寻道时间和旋转延迟，用寻道时间X2来估计磁盘访问时间</div><div>磁盘控制器：维护着逻辑块号和实际物理磁盘扇区之间的映射关系</div><div><br/></div><div><span style="font-weight: bold;">11.连接IO设备</span></div><div><img src="/images/posts/csapp-c06/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">12.访问磁盘</span></div><div>CPU使用内存映射IO（memory-mapped I/O）技术来向IO设备发射命令</div><div>将外围设备映射到内存空间（预留的一块地址），便于CPU的访问</div><div>DMA传送：直接内存访问，不需要CPU的干涉，磁盘控制器通过向CPU发送中断信号来通知CPU</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.CPU将命令、逻辑块号和目的内存地址写到写到与磁盘相关联的内存映射地址（内存空间），发起磁盘读；</div><div>2.磁盘控制器读扇区，执行到主存的DMA传送；</div><div>3.当DMA传送完成时，磁盘控制器用中断的方式通知CPU</div></div><div><img src="/images/posts/csapp-c06/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div><span style="font-weight: bold; font-size: 12pt;">局部性原理</span></div><div>1.时间局部性：被引用的内存在不远的将来被再次引用；</div><div>   空间局部性：一个内存位置在不远的将来引用附近的一个内存位置；</div><div><br/></div><div>2.重复引用相同变量的程序有良好的时间局部性；</div><div>   步长越小，空间局部性越好；</div><div>   循环有好的时间和空间局部性；</div><div><br/></div><hr/><div><span style="font-size: 12pt; font-weight: bold;">存储器层次结构 </span><span style="font-size: 12pt;">memory hierarchy</span></div><div><span style="font-weight: bold;">1.中心思想</span>：对于每个K，位于K层的更快更小的存储设备作为位于K+1层的更大更慢的存储设备的缓存；</div><div>2.数据总是以块大小为传送单元（transfer unit）在第K层和第K+1层之间来回复制的；</div><div><span style="font-weight: bold;">3.缓存不命中</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>强制性不命中 =&gt; 冷缓存</div><div>冲突不命中 =&gt; 映射到同一缓存块</div><div>容量不命中 =&gt; 工作集太大超过缓存的大小</div></div><div><br/></div><div><img src="/images/posts/csapp-c06/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><img src="/images/posts/csapp-c06/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">4.通用的高速缓存存储器组织结构</span></div><div><img src="/images/posts/csapp-c06/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><img src="/images/posts/csapp-c06/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">5.直接映射高速缓存 direct-mapped cache</span></div><div>1.每个组只有一行（E=1）的高速缓存 </div><div>2.命中过程</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.组选择，解析Set index；</div><div>2.行匹配，Tag位匹配</div><div>3.字选择，Block offset对应块</div><div>4.替换策略，新行替换当前行</div></div><div><br/></div><div><span style="font-weight: bold;">6.组相联高速缓存</span></div><div>1.解决直接映射高速缓存中冲突不命中造成的问题（E=1）；</div><div>2.命中过程 =&gt; 行匹配时，组中的任何一行都可以包含任何银蛇到这个组中的内存块</div><div>3.替换算法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>LFU Least-Frequently-Used：最不常使用算法</div><div>LRU Least-Recently-Used：最近最少使用算法</div></div><div><br/></div><div><span style="font-weight: bold;">7.全相联高速缓存</span></div><div>E = C / B，只有一个包含所有高速缓存行的组</div><div><img src="/images/posts/csapp-c06/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">8.写的问题</span></div><div>写命中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>直写：立即写入到低一层缓存中</div><div>写回：只在替换算法需要驱逐块时才写</div></div><div>写不命中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>写分配：加载到高速缓存，然后再更新缓存块，可利用写的空间局部性；</div><div>非写分配：避开高速缓存，直接写到低一层中；</div></div><div><br/></div><hr/><div><span style="font-weight: bold; font-size: 12pt;">CPU中的高速缓存层次结构</span></div><div><img src="/images/posts/csapp-c06/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div><span style="font-weight: bold; font-size: 12pt;">存储器山</span></div><div>存储器山：读吞吐量的时间和空间局部性的二维函数</div><div><img src="/images/posts/csapp-c06/Image [14].png" type="image/png" data-filename="Image.png"/></div><div>Stride：影响空间局部性，取临近内存块的可能性；</div><div>Size：影响时间局部性，工作集能否完全放入指定高速缓存；</div></div><div><br/></div><div><br/></div></span>
</div>