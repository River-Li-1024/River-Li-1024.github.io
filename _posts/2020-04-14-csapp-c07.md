---
layout: post
title: 笔记：<深入理解计算机系统>-C07.链接
categories: 技术笔记
description: 链接
keywords: 操作系统,csapp
---

<a name="4604"/>

<div>
<span><div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">总结：</span></font></div><div>1.有基本原理后，熟练使用工具；</div><div>2.熟悉编译器各过程；</div><div>3.了解ELF内数据含义；</div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">链接</span></div><div>1.链接：将各种代码和数据片段收集并组合成一个单一文件的过程；</div><div>   可执行于：compile time / load time / run time</div><div><br/></div><div>2.编译器驱动程序  compiler driver</div><div><img src="/images/posts/csapp-c07/Image.png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>cpp 预处理        -&gt; .i</div><div>cc1 编译器        -&gt; .s</div><div>as 汇编器         -&gt; .o</div><div>ld 链接器         -&gt; .exe</div></div><div><br/></div><div>3.静态链接 static linking</div><div>1.输入：多个可重定位目标文件 + 命令行参数</div><div>2.生成：完全链接的，可执行目标文件</div><div>3.两个主要任务：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.符号解析 symbol resolution    =&gt; 将每个符号引用和一个符号定义关联起来</div><div>2.重定位 relocation             =&gt; 每个符号定义和一个内存位置关联起来</div></div><div><br/></div><div>4.目标文件形式：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.可重定位目标文件 Relocatable object file</div><div>2.可执行目标文件 Executable object file</div><div>3.共享目标文件 Shared object file</div></div><div>Windows =&gt; Portable Executable     PE格式</div><div>Linux =&gt; Executable and Linkable Format ELF格式</div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">可重定位目标文件 Relocatable object file</span></div><div>1.ELF文件格式</div><div><img src="/images/posts/csapp-c07/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>2.各节section描述</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>.text      机器代码</div><div>.rodata    只读数据，归属于代码区，如switch跳转表</div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">.data            已初始化或初始化为0的全局和静态C变量</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">.bss              未</span>初始化的全局和静态C变量，仅仅是占位符</div><div><br/></div><div>.symtab    定义和引用的函数和全局变量信息</div><div>.rel.text  重定位条目（外部函数和全局变量引用），.text节中位置的列表，待补充</div><div>.rel.data  重定位条目（引用或定义的全局变量）</div><div><br/></div><div>.debug     调试符号表</div><div>.line      源码和.text中机器指令之间的映射</div><div>.strtab    字符串表</div></div><div><br/></div><div>3.查看ELF格式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>readelf -a addvec.o</div></div><div><img src="/images/posts/csapp-c07/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>4.重定位目标文件中的符号和符号表</div><div>符号类型：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.定义的全局符号：函数和全局变量</div><div>2.引用的全局符号：函数和全局变量</div><div>3.局部符号：定义和引用的static函数和全局变量</div></div><div><br/></div><div>5.符号表 .symtab</div><div>5.1 符号表中的条目</div><div><img src="/images/posts/csapp-c07/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>name        在字符串表中的符号偏移    .strtab</div><div>type        符号的类型：FUNC 或 OBJECT 或 NOTYPE</div><div>binding     Local或Global</div><div>reserved    未使用</div><div>section     符号被分配到的目标文件的某个节</div><div>value       在节内的偏移，如果被重定位后，变成绝对内存地址</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">size                目标的大小</span></div></div><div><br/></div><div><br/></div><div>5.2 查看main.o中的条目</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># readelf -a main.o</div></div><div><img src="/images/posts/csapp-c07/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>5.3 每个符号都被分配到某个节，由section字段标识（序号表示section序号），有3中伪section</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">ABS                不该被重定位的符号</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">UNDEF           引用的外部符号</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">COMMON      未分配/未初始化的数据</span></div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">符号解析</span></div><div>1.符号解析</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.关联符号引用和定义    =&gt; <b>依赖重定位文件中的.symtab条目</b></div><div>2.引用其它目标的符号，生成链接器符号表条目(中间数据)</div></div><div><br/></div><div>2.如何解析多重定义的全局符号</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>强符号：函数和已初始化的全局变量</div><div>弱符号：未初始化的全局变量</div></div><div>处理多重定义的全局符号</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.不允许有多个同名的强符号 =&gt; 直接报错</div><div>2.一个强符号和多个弱符号，选择强符号</div><div>3.多个弱符号，选择任意一个</div></div><div><br/></div><div>3.针对规则2/3中导致的歧义，使用GCC -fno-common 选项</div><div>    =&gt; 可在遇到多重定义符号时，触发一个错误  (伪section伪COMMON，表示未分配/初始化，属于弱符号)</div><div><br/></div><div>4.静态库 static library</div><div>存档(archive)的格式存放在磁盘；</div><div>是一组连接起来的可重定位目标文件的集合；</div><div>有一个头部描述每个成员目标文件大大小和位置；</div><div>用于链接时，内部按可重定位目标文件是否被使用，拷贝到最终可执行文件中 =&gt; 按object file复制</div><div>创建静态库工具ar</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># ar rcs libvector.a addvec.o multvec.o<span>    </span></div></div><div>使用静态库链接（-L.用于指定搜索路径）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># gcc -static -o a.out main.o -L. -lvector</div><div># gcc -static -o a.out main.o ./libvector.a</div></div><div><br/></div><div>5.链接器使用静态库来解析引用</div><div>从左到右按照他们在命令行上出现的顺序来扫描可重定位目标文件（也可能来自.c文件）和存储文件（static library）。</div><div>算法:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>集合E    可重定位目标文件集合    =&gt; 最终合并入可执行文件的重定位文件集合；</div><div>集合U    未解析的符号集合（找到引用，还没有发现定义）；</div><div>集合D    来自前面已输入文件的已定义符号集合；</div><div><br/></div><div><font face="Monaco">如果f是可重定位目标文件，则添加进E，并更新U和D</font></div><div><font face="Monaco">如果f是存档文件，则遍历其内部可重定位目标文件f2，尝试匹配U中符号；有找到则将f2添加进集合E，直至U和D不再变化；</font></div><div>完成扫描后，如果集合U非空，报错有符号未找到定义；否则合并E中的所有可重定位目标文件（同时重定位），输出可执行文件；</div></div><div>问题：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.依赖命令行顺序：将库放在命令行末尾</div><div>2.循环依赖：重复库、多库合并</div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">重定位</span></div><div>1.两步组成：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.重定位<b>节和符号</b>定义    =&gt; 节合并、为节/符号赋予内存地址</div><div>2.重定位节中的符号引用  =&gt; 修改节中的引用，使其指向正确的运行时地址 <b>依赖.rel.text或.rel.data中的重定位条目</b></div></div><div><br/></div><div>2.重定位条目</div><div>解决的问题：重定位目标模块不知道引用的外部函数和全局变量的位置，所以汇编器一旦遇到位置未知的引用时，产生一条重定位条目，</div><div>            用于告诉链接器在将来执行目标文件合并时，在可执行文件中修改这个引用（.text中的指令）</div><div><img src="/images/posts/csapp-c07/Image [5].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>offset        在节中的位置偏移，具体到指令内部的字节位置（需添加指令操作码）</div><div>type          修改类型，有两种常用类型：PC相对寻址引用 和 绝对寻址引用</div><div>symbol        符号表索引</div><div>addend        重定位时的补充位置偏移（因为PC是下一条指令的地址，所有需要额外的位置偏移）</div></div><div><br/></div><div><img src="/images/posts/csapp-c07/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>3.重定位过程--PC相对引用 R_X86_64_PC32</div><div>a.针对.text中的以下条目，只有操作码，没有实际函数地址，现在需要通过.rel.text的重定位条目获取地址；</div><div><img src="/images/posts/csapp-c07/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>b.在.rel.text中找到sum相关条目</div><div><img src="/images/posts/csapp-c07/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>c.执行以下算法，计算出待修改的地址refptr，PC相对引用的函数地址 refaddr</div><div><img src="/images/posts/csapp-c07/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>d.写入到可执行文件的.text中，形成最终效果</div><div><img src="/images/posts/csapp-c07/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>4.重定位过程--PC绝对引用 R_X86_64</div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">可执行目标文件</span></div><div>1.可执行文件里面的各类信息</div><div><img src="/images/posts/csapp-c07/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>2.加载可执行文件</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.shell进程生成子进程，子进程通过execve系统函数调用加载器；</div><div>2.加载器删除重置虚拟内存段，初始化为0；</div><div>3.加载器将虚拟地址空间映射到可执行文件的片chunk，新的代码和数据段初始化为可执行文件的内容；</div><div>4.加载器跳转到_start函数，最终调用main函数，启动程序；</div></div><div><br/></div><div>3.运行时内存映像</div><div><img src="/images/posts/csapp-c07/Image [12].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.代码段总是从0x40000开始，后面是数据段；也可能使用地址空间布局随机化，在前面插入一段空白；</div><div>2.用户栈从2^48-1开始往下分配空间；</div><div>3.Run-time heap从低位往上分配空间；</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">4.栈往上的空间是供内核中的代码和数据保留的，也就是操作系统驻留的内存部分；</span></div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">动态链接共享库</span></div><div>1.关于加载时的动态链接</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.在运行或加载时，加载到任意的内存地址，与内存中的程序链接起来；</div><div>2.创建可执行文件时，静态链接器完成部分链接：复制一些重定位和符号表信息；</div><div>3.动态链接器本质是一个共享目标文件（ld-linux.so），由加载器本身运行这个动态链接器；</div><div>4.动态链接器通过加载器链接时，需要重定位所有动态库，并将可执行文件中的符号引用重定位；</div></div><div><br/></div><div>2.运行时的动态链接</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.不使用fork和execve在子进程中运行shared library的函数，而是动态地加载和链接适当的函数；</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">2.基于linux提供的以下接口--由&lt;dlfcn.h&gt;提供</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    void *dlopen(const char *filename, int flags);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    void *dlsym(void *handle, char *symbol);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    int dlclose(void *handle);</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    const char* dlerror(void);</span></div></div><div>需要动态链接shared library的程序需要按以下方式编译</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># gcc -rdynamic -o a.out main.c -ldl</div></div><div>其中ldl是运行时动态链接库的静态库</div><div><br/></div><div>3.位置无关代码</div><div>Position-Independent Code   IPC</div><div>使用-fpic选项指示编译器生成IPC代码</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.IPC中的数据引用：全局偏移量表 GOT</div><div>2.IPC中的函数调用：延迟绑定  全局偏移量表GOT + 过程连接表PLT</div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 14pt; font-weight: bold;">库打桩</span></div><div>1.编译时打桩：</div><div>    增加与目标库同名的包装函数；</div><div>    重编译可执行文件，修改其库的查找路径</div><div><img src="/images/posts/csapp-c07/Image [13].png" type="image/png" data-filename="Image.png"/></div><div> 要求：可修改源代码，并需要重新编译可执行文件</div><div><br/></div><div>2.链接时打桩：</div><div>    获得原执行文件的可重定位目标文件；</div><div>    生成用于替换的重定位目标文件；</div><div>    利用静态链接器--wrap f标志重新链接可执行文件（链接器替换解析的函数名）</div><div><img src="/images/posts/csapp-c07/Image [14].png" type="image/png" data-filename="Image.png"/></div><div> <img src="/images/posts/csapp-c07/Image [15].png" type="image/png" data-filename="Image.png"/></div><div>要求：能获得原可执行文件的可重定位目标文件</div><div><br/></div><div>3.运行时打桩：</div><div>    利用重定义的LD_PRELOAD环境变量的查找路径；</div><div>    书写包装函数，内部可利用运行时动态链接查找到原函数；</div><div>    重新加载可执行文件；</div><div>  <img src="/images/posts/csapp-c07/Image [16].png" type="image/png" data-filename="Image.png"/></div><div><img src="/images/posts/csapp-c07/Image [17].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><hr/><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">可用工具</span></font></div></div><div><img src="/images/posts/csapp-c07/Image [18].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>