---
layout: post
title: 笔记：<深入理解计算机系统>-C08.异常控制流
categories: 技术笔记
description: 异常控制流
keywords: 操作系统,csapp
---

<a name="4675"/>

<div>
<span><div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">控制流</span></font></div><div>1.控制转移 Control Transfer：程序计数器中值的过渡</div><div>2.控制流 Control Flow：控制转移序列</div><div>3.异常控制流 Exceptional Control Flow ECF：为应对系统状态的变化，现代系统使控制流发生突变</div><div>4.ECF发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制；</div><div><br/></div><hr/><div><span style="font-size: 12pt; font-weight: bold;">异常</span></div><div>1.异常是ECF的一种形式，一部分由硬件实现，一部分由操作系统实现；</div><div>2.异常就是控制流中的突变，用来响应处理器中的某些变化；</div><div>3.异常处理：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>CPU检测到异常发生 =&gt; 事件</div><div><font face="Monaco">获得异常表中异常条目的地址 =&gt; 异常表基址寄存器 + 异常号 x 4 = 异常K的条目的地址</font></div><div><font face="Monaco">调用异常K的条目存储的处理程序代码的地址 =&gt; 类似过程调用</font></div><div><font face="Monaco">处理程序运行在内核模式下</font></div><div><font face="Monaco">通过“从中断返回”指令，可选地返回到被中断的程序</font></div></div><div><img src="/images/posts/csapp-c08/Image.png" type="image/png" data-filename="Image.png" title="点击下载"/></div><div>4.异常处理程序与过程调用的区别</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.异常处理程序压入栈中的返回地址，根据异常的类型，可能是当前指令或下一指令；</div><div>2.处理器压入额外的信息到堆栈，用于异常处理返回后重新执行指令；</div><div>3.如果控制从用户程序到内核，压到内核栈而不是用户栈；</div><div>4.异常处理程序运行在内核模式下；</div></div><div>5.异常类型</div><div><img src="/images/posts/csapp-c08/Image [1].png" type="image/png" data-filename="Image.png" title="点击下载"/></div><div><br/></div><div>中断：来自处理器外部IO设备，返回下一指令</div><div>陷阱：执行系统调用指令，返回下一指令；</div><div>故障：可能被修正的错误引起，返回当前指令或终止；</div><div>终止：不可恢复的致命错误，如硬件错误</div><div><br/></div><div>6.linux下的系统调用</div><div>供应用程序请求内核服务</div><div>通过一条syscall的陷阱指令来提供</div><div>标准C库提供一组标准的包装函数，也称为系统级函数</div><div>syscall表  <a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a></div><div>参数列表 %rax,%rdi,%rsi,%r10,%r8,%r9</div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt; font-weight: bold;">进程</span></div><div>1.进程：一个执行中的程序实例，是操作系统提供的抽象概念，异常是其基本构造块；</div><div>2.进程是提供应用程序的关键抽象：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.独立的逻辑控制流 =&gt; 独占地使用处理器</div><div>2.私有的地址空间 =&gt; 独占地使用内存系统</div></div><div><br/></div><div>3.逻辑控制流</div><div>并发流 Concurrency Flow：多个流并发执行（时间片重叠）=&gt; 与处理器核数无关</div><div>并行执行 Parallel Execution：是并发流的一个真子集</div><div><br/></div><div>4.私有地址空间</div><div>每个进程的地址空间有通用的结构</div><div><br/></div><div>5.用户模式和内核模式</div><div>内核模式：处理修改控制寄存器中的模式位</div><div>进入内核模式的方法：中断、故障、系统调用</div><div>/proc文件系统：允许在用户模式下访问内核数据结构的内容</div><div><br/></div><div>6.上下文切换</div><div>内核重新启动一个被抢占的进程所需的状态</div><div>包括；通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构；</div><div><br/></div><div>7.进程控制</div><div>进程状态：运行、停止（挂起）、终止</div><div><br/></div><div>8.fork</div><div>子进程得到与父进程用户级虚拟地址空间相同的一份副本</div><div>获得父进程的文件描述符副本</div><div>被调用一次，返回两次：父进程返回子进程PID，子进程返回0</div><div>特性：并发执行、相同但独立的地址空间、共享文件</div><div><br/></div><div>9.waitpid</div><div>被父进程回收：子进程终止（僵尸进程），当父进程回收时，内核将子进程的退出状态传递给父进程；</div><div>父进程被终止：内核安排init进程成为孤儿进程的父进程</div><div>waitpid：等待子进程终止或停止</div><div><br/></div><div>10.sleep/pause</div><div>sleep：挂起一段时间，可能被信号中断，则返回剩下的休眠时间</div><div>pause：让调用者休眠，知道收到信号</div><div><br/></div><div>11.execve</div><div>在当前进程的上下文中加载并运行一个程序</div><div>调用后不返回，除非出现错误</div><div>执行新程序时，用户栈的结构</div><div><img src="/images/posts/csapp-c08/Image [2].png" type="image/png" data-filename="Image.png" title="点击下载"/></div><div>操作环境数组数据的函数：getenv/setenv/unsetenv</div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt; font-weight: bold;">信号</span></div><div>1.高层的软件形式的异常，允许进程和内核中断其它进程</div><div>2.每种信号类型都对应某种系统事件，底层的硬件异常由内核处理程序处理；</div><div>3.信号提供一种机制：通知用户进程发生了异常</div><div><img src="/images/posts/csapp-c08/Image [3].png" type="image/png" data-filename="Image.png" title="点击下载"/></div><div><br/></div><div>4.默认忽略的信号：SIGCHLD（子进程终止或停止）, SIGCONT（进程继续） SIGURG（套接字上的紧急情况）SIGWINCH（窗口变化）</div><div>   进程时的信号：SIGSTOP SIGTSTP SIGTTIN SIGTTOU</div><div>   dump内存的信号：SIGTRAP SIGABRT SIGFPE SIGSEGV</div><div><br/></div><div>5.发送信号：内核更新目的进程上下文中的状态</div><div>   接受信号：目的进程被内核强迫对信号做出反应 =&gt; 调用信号处理程序（用户层）</div><div>   待处理信号：一种类型只有一个待处理信号，其它丢弃（不排队） =&gt; pending掩码实现</div><div>   阻塞信号：被接收为待处理信号，但不被处理 =&gt; blocked掩码实现</div><div>   </div><div>6.发送信号</div><div>/bin/kill -n PID            向pid进程发送信号n</div><div>Ctr+C                          发送SIGINT信号（终止）</div><div>Ctr+Z                          发送SIGTSTP信号（挂起）</div><div>kill(pid_t, int)               调用函数发送信号到进程或进程组</div><div>alarm(unsigned int)    调用函数发送SIGALARM信号</div><div><br/></div><div>7.接受信号</div><div>何时检查：内核将进程从内核模式切换为用户模式时，检查为被阻塞的待处理信号集合(pending &amp; ~blocked)</div><div>修改信号的默认行为：除SIGSTOP和SIGKILL</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>typedef void (*sighandler_t)(int)</div><div>sighandler_t signal(int signum, sighandler_t handler);</div></div><div>信号处理程序可以被其它信号处理程序中断</div><div><img src="/images/posts/csapp-c08/Image [4].png" type="image/png" data-filename="Image.png" title="点击下载"/></div><div><br/></div><div>8.编写安全、正确和可移植的信号处理程序</div><div>安全：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>处理程序尽可能简单:值修改状态</div><div>只调用异步信号安全的函数：两种办法：1.完全可重入函数；2.信号屏蔽保护</div><div><font face="Monaco">保存和恢复error</font></div><div><font face="Monaco">保护对共享数据结构的访问，阻塞所有信号</font></div><div><font face="Monaco">用volatile声明全局变量</font></div><div><font face="Monaco">用sig_atomic_t声明标志量</font></div></div><div><br/></div><div>9.使用可移植的信号处理接口和包装函数</div><div>原因：unix信号处理接口存在缺陷：1.语义不同；2.需要手动重启系统调用</div><div>包装POSIX中的sigaction函数，提供以下语义：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.只有正在处理的信号被阻塞；</div><div>2.信号不排队</div><div>3.自动重启被中断的系统调用</div><div>4.一直保持安装的处理程序</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>152 handler_t *Signal(int signum, handler_t *handler)</div><div>153 {</div><div>154     struct sigaction action, old_action;</div><div>155</div><div>156     action.sa_handler = handler;</div><div>157     sigemptyset(&amp;action.sa_mask); /* <b>Block sigs of type being handled</b> */</div><div>158     action.sa_flags = SA_RESTART; /* <b>Restart syscalls if possible</b> */</div><div>159</div><div>160     if (sigaction(signum, &amp;action, &amp;old_action) &lt; 0)</div><div>161         unix_error(&quot;Signal error&quot;);</div><div>162     return (old_action.sa_handler);</div><div>163 }</div></div><div><br/></div><div>10.【重要】关于信号机制的一些总结：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.信号处理提供一种异步的方式捕获信号；</div><div>2.信号可被阻塞，但不排队，需要尽可能地处理；</div><div>3.信号到达的实际不确定，使用信号阻塞机制保护逻辑避免竞争；</div><div>4.pause()接口只在已执行后才能被信号打断；一旦被设置信号处理函数，在执行完信号处理函数后再被打断；</div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt; font-weight: bold;">非本地调整</span></div><div>1.用户级异常控制流形式，用于将控制转移而不经由调用-返回序列；</div><div>2.setjmp</div><div>保存当前调用环境到env缓冲区中，供后面longjmp使用</div><div>调用环境包括：程序计数器、栈指针、通用寄存器</div><div>调用一次，多次返回（通过longjmp）</div><div><br/></div><div>3.longjmp</div><div>恢复调用环境，从env缓冲区中，触发一个最近一次的setjmp返回</div><div><br/></div><div>4.非本地跳转的应用</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.允许从一个深层嵌套的函数调用中立即返回，无需解开调用栈；</div><div>2.longjmp会导致跳过所有中间调用，容易引发类似内存泄漏的后果；</div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt; font-weight: bold;">操作进程的工具</span></div><div>STRACE</div><div>PS</div><div>TOP</div><div>PMAP</div><div>/proc</div></div><div><br/></div></span>
</div>