---
layout: post
title: 笔记：<深入理解计算机系统>-C09.虚拟内存
categories: 技术笔记
description: 虚拟内存
keywords: 操作系统,csapp
---

<a name="4687"/>

<div>
<span><div><div><span style="font-size: 12pt; font-weight: bold;">虚拟内存及术语</span></div><div>1.Virtual Memory：对主存的一种抽象概念；</div><div>2.提供三个重要的能力：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.将主存定义成磁盘的高速缓存，只保存活动区域，并在其与磁盘之间来回传送数据；</div><div>2.为进程提供一致的私有地址空间，简化内存管理；</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">3.保护进程地址空间不被破坏；</span></div></div><div>3.物理寻址 Physical Addressing           PA</div><div>  虚拟寻址 Virtual Addressing         VA</div><div>  地址翻译 Address Translation         AT</div><div>  内存管理单元 Memory Management Unit         MMU</div><div>  地址空间 Address Space             AS</div><div><br/></div><div>4.地址空间的概念，清楚地区分了数据对象（字节）和它们的属性（地址），即，每个对象可以有多个独立的地址</div><div>5.虚拟内存的基本思想：每个地址都选自不同的地址空间 </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>虚拟地址  =&gt; 虚拟地址空间</div><div>物理地址  =&gt; 物理地址空间</div></div><div>6.虚拟内存作为缓存的工具-使用主存作为缓存</div><div>VM系统将虚拟内存分割为虚拟页(Virtual Page, VP)，物理内存被分割为物理页(Physical Page, PP)，大小都为P = 2^p字节</div><div>在32位系统中一般为4KB</div><div><img src="/images/posts/csapp-c09/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>页表 Page Table：存放在物理内存上，用于将虚拟页映射到物理页上；</div><div>页表条目 Page Table Entry  PTE：有效位 + 地址字段，其中地址字段根据是否设置，分别可能指向物理内存页地址或磁盘内存页地址；</div><div><img src="/images/posts/csapp-c09/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>缺页 Page Fault：触发缺页异常，调用内核中缺页异常处理程序（选择牺牲页，复制页到内存中），重新启动导致缺页的指令</div><div>交换 Swapping/页面调度 Paging：在磁盘和内存之间传送页的活动；</div><div>按需页面调度 Demand Paging：延迟到只在不命中发生时且需要牺牲时才换入/换出页面；</div><div><br/></div><div>7.虚拟内存作为内存管理的工具</div><div>操作系统为每个进程提供了一个独立的页表，因而也就是独立的虚拟地址空间</div><div>多个虚拟页可以映射到同一个共享物理页面上；</div><div>按需页面调度和独立的虚拟地址空间的结合，对系统内存的使用和管理的影响：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.简化链接 =&gt; 进程有相同的地址空间，链接器可生成完全连接的可执行文件（独立于物理内存）；</div><div>2.简化加载 =&gt; 使用内存映射，加载器不复制任何数据，而是由虚拟内存按需自动页面调度；</div><div>3.简化共享 =&gt; 将不同进程适当的虚拟页面映射到相同的物理页面（共享文件的物理页面）;</div><div>4.简化内存分配 =&gt; 虚拟内存请求额外内存时，操作系统将连续的页面请求映射到物理内存页面（可随机地分散在物理内存中）；</div></div><div><img src="/images/posts/csapp-c09/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>8.虚拟内存作为内存保护的工具</div><div>在PTE(页表条目)中增加3个许可位：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SUP        进程是否在内核（超级）模式下才可访问此页面；</div><div>READ       </div><div>WRITE      进程对页面的读/写访问许可</div></div><div>如果CPU指令违反这些许可条件，则触发异常（一般性保护故障），一般是“段错误 Segmentation Fault”</div><div><br/></div><div>9.地址翻译 Address Translation</div><div><img src="/images/posts/csapp-c09/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><img src="/images/posts/csapp-c09/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>展示MMU利用页表实现从VA到PA的地址翻译：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.PTBR 页表基址寄存器,使得VA中只需是使用虚拟页号(VPN)即可；</div><div>2.VPO=PPO 代表虚拟/物理页偏移量，假设页面大小为64字节，则需6字节；</div><div>3.合并PPN和PPO得到实际物理地址；</div></div><div><br/></div><div>10.利用TLB加速地址翻译</div><div>Translation Lookaside Buffer TLB：在MMU中引入一个关于PTE的小缓存，翻译后备缓冲区 </div><div>TLB基于虚拟地址的VPN做选择</div><div><img src="/images/posts/csapp-c09/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>TLB具有高度的相联度</div><div><img src="/images/posts/csapp-c09/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>11.多级页表 Multi-Level Page Tables</div><div>用于压缩页表，避免多大的页表驻留在内存中</div><div><img src="/images/posts/csapp-c09/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>K级页表的地址翻译：将虚拟地址中的VPN分段对应到各层页表，如下图：</div><div><img src="/images/posts/csapp-c09/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt; font-weight: bold;">案例研究 Intel Corei7</span></div><div>1.处理器封装包</div><div><img src="/images/posts/csapp-c09/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.Core i7支持48位虚拟地址空间（256T）和52位物理地址空间（4PB）；</div></div><div><br/></div><div>2.地址翻译流程</div><div><img src="/images/posts/csapp-c09/Image [10].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">1.TLB都在L1之前，使其可优先利用缓存；</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">2.L1-d cache的访问使用物理地址；</span></div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt; font-weight: bold;">Linux的虚拟内存系统</span></div><div>1.Linux将虚拟内存组织成一些区域（段section）的集合，虚拟页再从属于某个区域，而内核只需记录区域即可（可能不连续）;</div><div>2.一个进程的虚拟内存中，有一部分用于内核虚拟内存，其中保存有进程虚拟内存的组织结构；</div><div><img src="/images/posts/csapp-c09/Image [11].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>pgd    指向第一级页表的基址</div><div>mmap   指向第一个区域（段）结构的地址</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">=&gt; 进程的虚拟内存描述的是一段映射关系，而不是一段真正分配的内存空间；</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><hr/><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">内存映射</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">1.Memory Mapping：将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容；</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">2.可被映射的文件类型</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.普通文件 普通磁盘文件，按需载入到物理内存</div><div>2.匿名文件 用二进制0覆盖更新页，请求二进制零的页</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">3.交换文件 Swap file：内核用来管理虚拟页面的机制，也称为交换空间/交换区域</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">4.加载共享对象和私有对象</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">共享对象映射到进程虚拟内存的共享区域；</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">私有对象使用一种叫做</span><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">写时复制(Copy-on-write)</span><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">的技术被映射到虚拟内存中=&gt;延时创建私有对象的副本</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><img src="/images/posts/csapp-c09/Image [12].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">5.fork函数</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">将两个进程的每个页面都标记为只读，并将两个进程中每个区域结构都标记为写时复制；</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">当任一进程进行写操作时，写时复制机制就会创建新页面；</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">6.execve函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#333333" face="Monaco">1.删除当前进程虚拟地址空间中用户部分的区域结构；</font></div><div><font color="#333333" face="Monaco">2.创建新的区域结构，并映射到为私有区域；</font></div><div><font color="#333333" face="Monaco">3.映射共享区域</font></div><div><font color="#333333" face="Monaco">4.设置程序计数器PC，指向代码区域的入口点；</font></div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><img src="/images/posts/csapp-c09/Image [13].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 9pt;">7.mmap函数</span></div><div><span style="font-size: 12px;">创建新的虚拟内存区域，并将对象映射到这些区域中；</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void *mmap(void *start, size_t length, int port, int flags, int fd, of_t offset);</div></div><div><span style="font-size: 9pt;">start地址仅仅是一个暗示</span></div><div><span style="font-size: 12px;">删除虚拟内存区域</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int munmap(void *start, size_t length);</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><hr/><div><span style="font-size: 12pt; font-weight: bold;">动态内存分配</span></div><div><span style="font-size: 12px;">1.动态内存分配器 Dynamic memory allocator</span></div><div><span style="font-size: 12px;">分配器维护着一个进程的虚拟内存区域，称为堆heap =&gt; 请求二进制零的区域</span></div><div><span style="font-size: 12px;">分配器将堆视为一组不同大小的块(block)的集合来维护</span></div><div><span style="font-size: 12px;">有两种风格类型：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.显式分配器 explicit allocator =&gt; 要求应用显式地释放任何已分配的内存</div><div>2.隐式分配器 implicit allocator =&gt; 垃圾收集器 garbage collector</div></div><div><span style="font-size: 12px;">增加incr指针来扩展和收缩堆</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void *sbrk(intptr_t incr);</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;">2.内存碎片</span></div><div><span style="font-size: 12px;">内部碎片：已分配块比有效荷载大时发生；</span></div><div><span style="font-size: 12px;">外部碎片：没有一个单独的空闲块可用来处理请求；</span></div><div><span style="font-size: 12px;"><br/></span></div><div><span style="font-size: 12px;">3.隐式空闲链表</span></div><div><span style="font-size: 12px;">堆块的格式：头部（字，块大小+标志位）+ 有效荷载+ 填充</span></div><div><span style="font-size: 9pt;"><img src="/images/posts/csapp-c09/Image [14].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 12px;">因为要求8字节对齐，所以低3位都用于作为标志位；</span></div><div><span style="font-size: 9pt;"><img src="/images/posts/csapp-c09/Image [15].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 12px;">隐式空闲链表：空闲块是通过头部中的大小字段隐含地连接着的；</span></div><div><span style="font-size: 12px;">搜索所需时间与</span><span style="font-size: 12px; font-weight: bold;">已分配块和空闲块的总数</span><span style="font-size: 12px;">呈线性关系；</span></div><div><span style="font-size: 12px;">最小块大小限制：来自对齐要求和块格式的限制；</span></div><div><span style="font-size: 12px;">放置策略 placement policy：搜索隐式空闲链表查找一个足够大可放置所请求块的空闲块。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">首次适配 first fit</font></div><div><font face="Monaco">下一次适配 next fit</font></div><div><font face="Monaco">最佳适配 best fit</font></div></div><div><br/></div><div>4.分割空闲块</div><div>5.合并空闲块：当找不到合适的空闲块时，合并相邻的空闲块，关键是如何合并前面的块</div><div>带边界标记的合并（header+footer）</div><div><img src="/images/posts/csapp-c09/Image [16].png" type="image/png" data-filename="Image.png"/></div><div>在每种情况下，合并都是在常数时间内完成；</div><div>潜在缺陷：分配许多小块时，会产生显著的内存开销（内部碎片）；</div><div>优化方法：只在前面的块是空闲块时，才需要在分配块中添加脚部（空闲块仍需要脚部）；</div><div><br/></div><div><br/></div><hr/><div><span style="font-weight: bold; font-size: 12pt;">综合：实现一个简单的分配器</span></div><div><br/></div><div><br/></div><hr/><div><span style="font-weight: bold; font-size: 12pt;">显式空闲链表</span></div><div>1.将空闲块组织成某种形式的显式数据结构（如，多为多列），且在空闲块中放置实现这个数据结构的指针等；</div><div><img src="/images/posts/csapp-c09/Image [17].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>2.使用双向链表而不是隐式空闲链表（隐式空闲指已分配和空闲块都在链表中，通过头部位来区分）；</div><div>这使得，首次适配的放置策略时间从块总数的线性时间较少到空闲块总数的线性时间；</div><div><br/></div><div>3.块释放的时间依赖空闲链表中空闲块的排序策略；</div><div>两种算法（LIFO、按地址顺序排序），其中后者的内存利用率更高；</div><div>缺点：更大的最小块大小，因为需要包含所有需要的指针；</div><div><br/></div><div>4.分离的空闲链表</div><div>目的：减少分配时查找放置位置的时间（单向空闲块链表的分配器需要与空闲链表数量呈线性关系）</div><div>分离存储 Segregated Storage：维护多个空闲链表，每个链表中的块有大致相等的大小（大小类 size class）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>如何定义大小类</div><div>是否允许分割</div><div>合适向OS请求额外的堆内存</div><div>如何/合适进行合并</div></div><div><br/></div><div>5.简单分离存储</div><div>每个块的大小是大小类中最大元素的size决定；</div><div>按分配size需要查找到链表，分配第一块，释放时将其插入到前部</div><div>不分割，不合并，单向链表，无需脚部</div><div>缺点：容易造成内部/外部碎片（不分割-&gt;内部碎片  不合并-&gt;外部碎片）</div><div><br/></div><div>6.分离适配（GNU malloc实现）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.分配器维护一个空闲链表的数组，每个空闲链表和大小类相关联，但存在大小不同的块；</div><div>2.分配：确定大小类，遍历查找合适的块，分割，剩余部分插入到适当大小的空闲链表；如果没找到，找类更大的空闲链表</div><div>3.额外请求堆内存：分割，剩余部分插入到适当大小的空闲链表中；</div><div>4.释放：执行合并，将结果放置到适当大小的空闲链表中；</div></div><div>优点：搜索范围被限制在堆的某个部分</div><div>利用率改善：首次适配法也能获得获得最佳适配搜索的内存利用率（得益于按大小类组织空闲链表数组）</div><div><br/></div><div>7.伙伴系统</div><div>Buddy system：以上分离适配的一个特例，每个大小类都是2的幂</div><div>特点：能快速对块做分割（被分割后的块成为伙伴），每次分割必然是二分切割，且能快速获取伙伴地址</div><div>释放时：如果伙伴空闲则合并，否则停止合并</div><div><br/></div><div><br/></div><hr/><div><span style="font-weight: bold; font-size: 12pt;">垃圾收集</span></div><div>1.McCarthy的Mark&amp;Sweap（清除&amp;标记）算法；</div><div>2.垃圾收集器将内存视为一张有向可达图；</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Heap Nodes：已分配块；</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Root Nodes：包含指向堆中的指针，可以是寄存器、栈的变量、全局变量</span></div></div><div><img src="/images/posts/csapp-c09/Image [18].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>3.Java/ML等语言因为对指针有严格的控制，所以可维护可达图的一种精确表示，也就能回收所有的垃圾；</div><div>C/C++语言无法准确标记，所有是保守的垃圾收集器</div><div><br/></div><div>4.垃圾收集器的标记和清除算法</div><div><img src="/images/posts/csapp-c09/Image [19].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.标记时，需要遍历每个字节的内容，查看器是否指向其他已分配节点；</div><div>2.清除时，通过隐式块链表获取b的下一块;</div></div><div><br/></div><div>5.C语言的isPtr()函数实现困难</div><div>C语言无法确定参数p是指针还是int，更无法从p确定其是否指向已分配块的有效荷载中的某个位置；</div><div>将分配块集合维护成一个平衡二叉树，树的左节点地址一定小于右节点；</div><div>isPtr函数用树来执行对已分配块的二分查找（依赖于节点头部中的大小字段判断p是否在此块范围内）</div><div><img src="/images/posts/csapp-c09/Image [20].png" type="image/png" data-filename="Image.png"/></div><div>C语言的Mark&amp;Sweep收集器是保守的，因为C语言不会用类型信息来标记内存（位置）；</div><div><br/></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-weight: bold; font-size: 12pt;">C语言中的常见的与内存有关的错误</span></div><div>1.间接引用坏指针；引用虚拟地址空间中未使用的区域</div><div>2.读未初始化的内存：堆内存分配时不会自动初始化，使用前需要置空；</div><div>3.允许栈缓冲区溢出：没有检查栈操作范围；</div><div>4.假设指针和他们指向的对象是相同大小的：int*的大小是依赖机器的，不一定是int大小</div><div>5.造成错位错误：范围数组越界了，修改了别处的内存区域；</div><div>6.引用指针，而不是它所指向的对象：*size -1，需要特别注意操作符优先级</div><div>7.误解指针运算：指针的算术运算会考虑指针指向的数据类型</div><div>8.引用不存在的变量：返回局部变量指针</div><div>9.引用空闲块中的数据：被free后的内存，仍被引用</div><div>10.引起内存泄漏：malloc后没有free</div><div><br/></div><div><br/></div><hr/><div><span style="font-weight: bold;">工具</span></div><div>getrusage函数 监测缺页的数量</div></div><div><br/></div></span>
</div>