---
layout: post
title: 笔记：<深入理解计算机系统>-C10.系统级IO
categories: 技术笔记
description: 系统级IO
keywords: 操作系统,csapp
---

<a name="4819"/>

<div>
<span><div><div><b><font style="font-size: 12pt;">Unix I/O</font></b></div><div>1.所谓IO：在主存和外部设备之间赋值数据的过程</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Input：外部设备 -&gt; 主存</div><div>Output：主存 -&gt; 外部设备</div></div><div>2.所有语言运行时（runtime）都提供执行IO的高级别工具<br/></div><div>3.Linux系统中，由内核提供系统级IO函数</div><div>4.所有的IO设备都被<b>模型化</b>为文件，而所有的输入和输出都被当做对相应文件的读写来执行；</div><div><br/></div><div><br/></div><hr/><div><b><font style="font-size: 12pt;">文件</font></b></div><div>1.每个Linux文件都有一个类型（type）来表明它在系统中的角色；</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>普通文件 regular file：应用程序区分文本文件和二进制文件，对内核而言没有区别；</div><div>目录 directory：包含一组<b>链接(link)</b>的文件，每个目录文件至少包含两个条目(./..)；</div><div>套接字 socket：用于与另一进程进项跨网络通信的文件；</div><div>命名通道 named pipe：</div><div>符号链接 symbolic link：</div><div>字符和块设备 character and block device：</div></div><div><br/></div><div>2.打开/关闭文件</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int open(char *filename, int flags, mode_t mode);</div><div>int close(int fd);</div></div><div>flags：进程如何访问文件</div><div>mode：文件的访问权限，定义为 mode &amp; ~umask，其中umask通过umask(mode_t mode)来设置</div><div><img src="/images/posts/csapp-c10/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>3.读写文件</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ssize_t read(int fd, void *buf, size_t n);</div><div>ssize_t write(int fd, const void *buf, size_t n);</div></div><div>返回值-1表示错误，0表示EOF</div><div>返回不足值：不表示错误，但原因可能有：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.遇到EOF，返回字节数，下一次读返回EOF；</div><div>2.从终端读取文本行，返回文本行大小；</div><div>3.读写网络套接字，内部缓冲约束和延迟导致；</div></div><div><b>=&gt; 处理不足值：读写磁盘不会产生，但网络应用必须反复调用read/write</b></div><div><br/></div><div>4.Robust IO，健壮的IO-自动处理不足值</div><div><b>无缓冲的IO函数</b></div><div>没有应用级缓冲，适用于网络读写</div><div>在内存和文件之间直接传送数据/绝不返回不足值/允许被中断的系统调用</div><div>效率不高，每次读写都会陷入内核</div><div><img src="/images/posts/csapp-c10/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><b>带缓冲的IO函数：</b></div><div>缓存在应用级缓冲区中，线程安全的</div><div>调用rio_readinitb将描述符fd与rio_t类型的缓冲区联系起来（线程安全）</div><div><img src="/images/posts/csapp-c10/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>内部核心函数rio_read，自动填满缓冲，允许返回不足值，基于linux的read函数（可多次调用而不陷入内核）</div><div><img src="/images/posts/csapp-c10/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>行读取和二进制读取，基于rio_read实现</div><div><img src="/images/posts/csapp-c10/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div><b><font style="font-size: 12pt;">读取文件元数据（文件信息）</font></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int stat(char *filename, struct stat *buf);</div><div>int fstat(int fd, struct stat *buf);</div></div><div>struct stat的数据结构</div><div><img src="/images/posts/csapp-c10/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>st_mode<span>    定义文件类型和访问方式<span>    =&gt; 通过宏谓词来判断文件类型</span></span></div><div><span>st_size<span>    </span><span>    文件字节数</span></span></div><div><span><br/></span></div><div><span><br/></span></div><hr/><div><b><font style="font-size: 12pt;">读取文件目录</font></b></div><div>DIR<span>    目录流，流是对条目有序列表的抽象，这里指目录项的列表</span></div><div><span>struct dirent<span>    目录项结构</span></span></div><div><img src="/images/posts/csapp-c10/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>访问文件目录接口：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>DIR *opendir(const char *filename);</div><div>struct dirent * readdir(DIR *dirp);<span>    =&gt;只能通过errno检查调用状态</span></div><div>int closedir(DIR *dirp);</div></div><div><span><br/></span></div><div><span><br/></span></div><hr/><div><b><font style="font-size: 12pt;">共享文件</font></b></div><div>1.内核用三个相关的数据结构来表示打开的文件</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>描述符表 descriptor table：每个进程独有</div><div>文件表 file table：所有进程共享，表项内容有：文件位置、引用计数、v-node项指针</div><div>v-node表 v-node table：所有进程共享，表项内容有：文件元数据（struct stat中的大多数信息）</div></div><div><br/></div><div>2.文件共享结构（多次open同一个文件名）</div><div><img src="/images/posts/csapp-c10/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>3.fork形成的文件共享结构</div><div><img src="/images/posts/csapp-c10/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><hr/><div><b><font style="font-size: 12pt;">IO重定向</font></b></div><div>重定向：将磁盘文件与标准输入输出联系起来</div><div>使用dup2定义重定向：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int dup2(int oldfd, int newfd);</div></div><div>=&gt; 复制描述符表中，oldfd到newfd =&gt; 使得newfd指向与oldfd相同</div><div><img src="/images/posts/csapp-c10/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div><b><font style="font-size: 12pt;">标准IO和网络套接字</font></b></div><div>1.C语言定义的高级输入输出函数，基于Unix IO</div><div>2.将一个打开的文件模型化为一个流 =&gt; 指向FILE类型的结构的指针；</div><div>3.FILE流是对文件描述符和流缓冲区的抽象，但不解决返回不足值的问题；</div><div>4.选用IO函数的原则</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.首选标准IO =&gt; stat除外</div><div>2.读取二进制文件，不能使用scanf/rio_readlineb</div><div>3.读写网络套接字使用功能rio函数，不能使用标准IO</div></div><div>5.对流的限制（见以下描述）和对套接字的限制（使用lseek是非法的）会互相冲突</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>对流的限制</div><div>1.输出后接输入函数 =&gt; 中间需要插入fflush,fseek,fsetpos,rewind，要么重置缓冲区，要么重设置文件位置</div><div>2.输入后接输出函数 =&gt; 中间需要插入fseek,fsetpos,rewind，除非遇到一个文件结束符</div></div><div>6.因为套接字不能使用lseek，所以以上对流的限制会导致第二种情况出错</div><div>创建两个流分别读写，但在多线程下多次close会出错</div><div><b>=&gt; 建议在网络套接字上不能使用标准IO，而是使用rio</b></div><div><br/></div><div><br/></div></div></span>
</div>