---
layout: post
title: 笔记：<深入理解计算机系统>-C11.网络编程
categories: 技术笔记
description: 网络编程
keywords: 操作系统,csapp
---

<a name="4831"/>

<div>
<span><div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">ERICM网络编程模型</font></span></div><div>1.每个网络应用都是基于客户端-服务器模型的</div><div>2.模型中的基本操作是事务（transaction） =&gt; 仅仅是一些步骤</div><div>3.对主机而言，网络只是又一种IO设备，是数据源和数据接收方</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">网络 &lt;-&gt; 网络适配器 &lt;-&gt; 主存</font></div></div><div><img src="/images/posts/csapp-c11/Image.png" type="image/png" data-filename="Image.png"/></div><div>4.网络是一个按照地理远近组成的层次系统</div><div><span style="font-weight: bold;">LAN </span>   最流行的技术是以太网 Ethernet</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.每根电缆相同的带宽</div><div>2.集线器将从每个端口上收到的数据复制到其他所有端口上</div><div>3.主机适配器能看到所有帧，但只有目的主机读取它</div></div><div><img src="/images/posts/csapp-c11/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">Bridged Ethernet</span> 桥接以太网   组成较大的局域网</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">1.用网桥连接，自带分配算法，随时间自动学习哪个主机通过哪个端口可达  =&gt; 丢弃或转发</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">2.电缆带宽可以不同</span></div></div><div><img src="/images/posts/csapp-c11/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">internet</span> 互联网络   多个不兼容的局域网通过路由器(router，特殊的计算机)连接起来</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.路由器对每个其所连接的网络都有一个适配器（端口）</div><div>2.路由器也能连接高速点到点电话连接，称为广域网（WAN）</div></div><div><img src="/images/posts/csapp-c11/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>5.协议软件</div><div>用于跨越不兼容技术的局域网络互相通信</div><div>一层运行在每台主机和路由器上的协议软件，控制主机和路由器如何协同工作</div><div>协议提供的两种基本能力：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.命名机制 =&gt; 为每台主机分配至少一个互联网络地址（internet address）</div><div>2.传送机制 =&gt; 基于封装思想，定义一种把数据位捆扎成不连续的片（包）的统一方式</div></div><div><br/></div><div>6.在不兼容的局域网间传送数据的过程</div><div><img src="/images/posts/csapp-c11/Image [4].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.主机上的协议软件在数据上附加<b>互联网包头（PH）</b>和<b>局域网帧（FH1）;</b></div><div><b>2.</b>互联网包头用于寻址到目的互联网主机，局域网帧寻址到路由器；</div><div>3.路由器从互联网包头中提取出目的互联网络地址，作为路由表的索引，确定如何转发包；</div><div>4.路由器剥落旧的LAN1帧头，加上寻址到目的主机新的LAN2帧头；</div></div><div>=》 互联网的精髓思想是封装</div><div><br/></div><div><br/></div><hr/><div><span style="font-weight: bold;"><font style="font-size: 12pt;">TCP/IP</font></span></div><div>1.是一个协议族，每个都提供不同的功能；</div><div>2.IP协议（Internet Protocol），提供基本的命名方法和递送机制（主机与主机之间发送数据报datagram）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>不可靠的 =&gt; 丢失不会试图恢复</div></div><div>3.UDP协议（Unreliable Datagram Protocol），稍微扩展了IP协议（进程与进程间传送）</div><div>4.TCP协议（Transmission Control Protocol），建立在IP之上的复杂协议</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.点对点  =&gt; 进程间通信</div><div>2.可靠的 =&gt; 保持有序的最终到达</div><div>3.全双工 =&gt; 双向的流动</div></div><div><br/></div><div>5.IP地址   32位无符号整数/大端法</div><div><img src="/images/posts/csapp-c11/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>6.网络字节顺序和主机字节顺序的相互转化</div><div>host/net</div><div><img src="/images/posts/csapp-c11/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>7.IP地址（二进制的网络字节顺序）和点分十进制地址串（字符串）的相互转化</div><div>P presentation，点分十进制串</div><div>N network，二进制网络顺序IP地址</div><div><br/></div><div><img src="/images/posts/csapp-c11/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>8.域名</div><div>域名集合和IP地址集合之间的映射关系 =&gt; 域名系统 Domain Name System, DNS</div><div>NSLOOKUP 程序查看DNS映射的属性</div><div><img src="/images/posts/csapp-c11/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><hr/><div><span style="font-weight: bold;"><font style="font-size: 12pt;">因特网连接</font></span></div><div>1.套接字是连接的一个端点，都有相应的套接字地址（地址：端口）</div><div>从Linux程序的角度看，套接字就是一个有相应描述符的打开文件</div><div><br/></div><div>2.端口有两种类型：临时端口（客户端） + 知名端口(/etc/services，服务器)</div><div>3.一个连接是由它两端的套接字地址唯一确定的 =&gt; 套接字对(socket pair)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(cliaddr:cliport, servaddr:servport)</div></div><div>4.1972年，Robert Hahn概括了互联网络的一般原则：一组互相连接的网络，通过叫做“路由器”的</div><div>黑盒子按照“以尽力传送作为基础”在互相独立处理的网络间实现通信。</div><div><br/></div><div>5.套接字接口</div><div>一组函数，和Unix IO函数结合，用以创建网络应用。</div><div>通常实现为系统调用，陷入内核并调用各种内核模式的TCP/IP函数；</div><div><img src="/images/posts/csapp-c11/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>6.套接字地址结构</div><div>16字节结构体</div><div><img src="/images/posts/csapp-c11/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>通用类型struct sockaddr用于早起没有void*时，向connect/bind/accept传送与协议相关的套接字地址结构的指针。</div><div><br/></div><div>7.套接字接口</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">#include &lt;sys/types.h&gt;</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">#include &lt;sys/soskcet.h&gt;</span></div></div><div><br/></div><div>创建套接字描述符</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int socket(int domain, int type, int protocol);</div><div>int fd = socket(AF_INET, SOCK_STREAM, 0);</div><div>AF_INET    使用32位IP地址</div><div>SOCKET_STREAM    套接字是连接的一个端点</div></div><div><br/></div><div>建立和服务器的连接</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);</div><div>阻塞直到连接成功或发生错误</div></div><div><br/></div><div>服务器绑定套接字</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div><div>告诉内核将套接字描述符与套接字地址联系起来</div></div><div><br/></div><div><br/></div><div>服务器转化套接字为监听套接字</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">int listen(int sockfd, int backlog);</span></div><div>默认情况下，socket函数创建的是主动套接字（用于客户端），服务器需要转化为监听套接字</div></div><div><br/></div><div>服务器等待来自客户端的连接</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int accept(int listenfd, struct sockaddr *addr, int *addrlen);</div><div>返回已连接描述符</div><div>填充已连接套接字的地址</div></div><div><br/></div><div>8.getaddrinfo</div><div>转换：主机套接字字符串表示（host, service, port） =&gt; 二进制套接字地址（struct addrinfo）</div><div><img src="/images/posts/csapp-c11/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><img src="/images/posts/csapp-c11/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><img src="/images/posts/csapp-c11/Image [13].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>好处：可用于编写独立于任何特定版本的IP协议的网络程序，传递给socket函数作为参数（不透明的）</div><div><font face="Monaco">可重入的</font></div><div>调用getaddrinfo后，便利列表，尝试每个套接字地址，调用每个socket和connect成功，建立起连接（服务器类似）</div><div><font face="Monaco">分配的struct addrinfo需要调用freeaddrinfo释放；</font></div><div><font face="Monaco">使用gai_strerror获取错误消息字符串；</font></div><div><font face="Monaco">host可以是域名，也可以是地址；service可以使服务名，也可以是端口号；二选一</font></div><div><font face="Monaco">hints对返回地址列表做更多控制，只需设置部分选项：</font></div><div><font face="Monaco">1.ai_flags：AI_ADDRCONFIG-根据本地主机返回IPV4或IPV6地址</font></div><div><font face="Monaco">                  AI_CANONNAME-指定第一个addrinfo结构返回ai_canonname（host的权威名字）</font></div><div><font face="Monaco">                  AI_NUMERICSERV-强制service为端口号</font></div><div><font face="Monaco">                  AI_PASSIVE-返回套接字地址被用作服务器监听套接字（默认为主动套接字）</font></div></div><div><br/></div><div><br/></div><div>9.getnameinfo</div><div>转换：二进制套接字地址（struct addrinfo）=&gt; 主机套接字字符串表示（host, service, port）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>与getaddrinfo相反</div><div>可重入的，与协议无关的</div><div>flags用于修改默认的行为</div><div>    NI_NUMERICHOST    返回数字地址字符串</div><div>    NI_NUMERICSERV    返回服务名而不是端口</div></div><div><img src="/images/posts/csapp-c11/Image [14].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>10.套接字辅助接口</div><div>1.客户端创建套接字并建立与服务器的连接</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int open_clientfd(char *hostname, char *port);</div></div><div>2.服务器创建套接字并绑定到地址等待连接</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int open_listenfd(char *port);</div></div><div><br/></div><hr/><div><b><font style="font-size: 12pt;">Web服务器</font></b></div><div>1.MIME 多用于网际邮件扩充协议：服务器内容类型</div><div><img src="/images/posts/csapp-c11/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>2.HTTP请求事务的组成：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>请求行：<span>    </span>method URI version<span>    </span><span>    </span><span>    =&gt; GET / HTTP/1.1</span></div><div>请求报头：<span>  header-name:head-data<span>    </span><span>    </span><span> =&gt; Host:www.aol.com</span></span></div></div><div><br/></div><div>3.HTTP响应事务的组成：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>响应行：<span>    </span>version status-code status-message<span>    </span><span>    =&gt; HTTP/1.0 200 OK</span></div><div>响应包头：<span>  response-name:response-data<span>    </span><span>    </span><span>    </span><span>   =&gt; Content-Type:text/html</span></span></div></div><div><br/></div><div>4.CGI：Common Gateway Interface 通用网关接口</div><div>用于服务器提供动态内容时，与服务器子进程通信的标准</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.传递参数到子进程：服务器在执行execve前，设置CGI环境变量；</div><div>2.重定向标准输出到客户端相关的已连接描述符；</div></div><div><br/></div></div><div><br/></div></span>
</div>