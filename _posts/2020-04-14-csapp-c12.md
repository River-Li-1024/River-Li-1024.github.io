---
layout: post
title: 笔记：<深入理解计算机系统>-C12.并发编程
categories: 技术笔记
description: 并发编程
keywords: 操作系统,csapp
---

<a name="4875"/>

<div>
<span><div><div><b>并发程序 concurrent program</b></div><div>现代操作系统提供3中基本的构造并发程序的方法：  =&gt; 创建并发逻辑流</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.进程 逻辑控制流，内核调度维护，独立虚拟地址空间，进程间通信（IPC）</div><div>2.IO多路复用 在进程内显式调度逻辑流（模型化为状态机），所有逻辑流共享地址空间</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">3.线程 在进程内由内核调度的逻辑流，是以上两种的混合体，共享地址空间</span></div></div><div><br/></div><div><br/></div><hr/><div><b>基于进程的并发编程</b></div><div>1.回收文件描述符：客户端连接后，服务器创建子进程，子进程关闭listenfd(3)，父进程关闭connfd(4)</div><div><img src="/images/posts/csapp-c12/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>2.编写基于进程的并发服务器需特别注意：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.回收僵死子进程：通过SIGCHILD信号处理程序（不排队）</div><div>2.父子进程关闭各自文件描述符connfd，避免内存泄漏</div></div><div><br/></div><div>3.进程的优劣</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.共享文件表，但不共享用户空间</div><div>2.进程共享状态信息变得困难</div><div>3.运行慢，进程控制和IPC的开销很高</div></div><div><br/></div><hr/><div><b>基于IO多路复用的并发编程</b></div><div>1.困境：服务器需要等到多个互相独立的IO事件（服务器连接请求、用户输入等），等待请求陷入困境；</div><div>2.IO多路复用 IO multiplexing技术：内核挂起进程，只有在一个或多个IO时间发生后，才将控制返回给应用程序。</div><div>3.select的执行过程：略</div><div>4.IO多路复用可用作并发事件驱动（event-driven）程序的基础：事件推动逻辑流前进</div><div>一般的思路是将逻辑流模型化为状态机（状态机中的转移是 [输入状态，输入事件]-&gt;输出状态）</div><div>借助select函数检测输入事件的发生，addclient函数保存客户端连接描述符用于创建新的逻辑流（状态机），</div><div>轮询中在chek_clients回送输入行（状态转移）</div><div><br/></div><div>5.IO多路复用的优缺点：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.给了更多对程序行为的控制；</div><div>2.运行在单一进程上下文中，所有逻辑流便于访问共有数据和通信；</div><div>3.缺点是编码复杂</div></div><div><br/></div><div><br/></div><hr/><div><b>基于线程的并发编程</b></div><div>1.线程：运行在进程上下文中的逻辑流；</div><div><br/></div><div>3.线程上下文比进程上下文小得多，所以切换更快</div><div>同一进程的所有线程组成对等（线程）池：一个线程可杀死或等待任何对等线程</div><div><br/></div><div>4.pthread是POSIX中定义的C中处理线程的标准接口，提供60个函数</div><div>thread routine 线程例程：线程代码和本地数据的封装</div><div>线程相关接口</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;pthread.h&gt;</div><div>//创建线程</div><div>typedef void *(func)(void *);</div><div>int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *args);</div><div>//返回自身线程ID</div><div>pthread_t pthread_self(void);</div><div>//显式终止线程，如果是主线程调用，则等待所有其它对等线程终止，阻塞</div><div>void pthread_exit(void *thread_return);</div><div>//对等线程终止自身</div><div>int pthread_cancel(pthread_t tid);</div><div>//等待指定线程终止,阻塞</div><div>int pthread_join(pthread_t tid, void **thread_return);</div><div>//分离线程，线程资源由系统自动释放</div><div>int pthread_detach(pthread_t tid);</div><div>//初始化线程状态</div><div>pthread_once_t once_control = PTHREAD_ONCE_INIT;</div><div>int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));</div></div><div><br/></div><div>5.<b>线程内存模型</b></div><div>由内核自动调度，线程上下文（线程ID，栈，栈指针，程序计数器，通用目的寄存器，条件码）</div><div>线程之间共享虚拟地址空间和打开文件集合</div><div>寄存器是不共享的，但虚拟内存总是共享的</div><div>不同的线程栈是不对其它线程设防的</div><div><br/></div><div>6.临界区 critical section</div><div>互斥 mutual exclusion：每个线程在执行临界区中的代码时，拥有对共享变量的互斥的访问</div><div><img src="/images/posts/csapp-c12/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>7.信号量 semaphore  =&gt; 特殊类型变量</div><div>解决同步不同执行线程问题的方法</div><div><img src="/images/posts/csapp-c12/Image [2].png" type="image/png" data-filename="Image.png" width="675"/></div><div>P和V操作都是不可分割的（加载、加减1，存储信号量的过程中没有中断）</div><div>V重启阻塞在P中的线程时，不能预测重启哪一个</div><div><b>互斥锁 mutex：以提供互斥为目的的二元信号量</b></div><div><img src="/images/posts/csapp-c12/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>8.利用信号量调度共享资源</div><div>信号量的两个重要应用：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.提供互斥访问<span>    =&gt; 互斥锁</span></div><div>2.调度对共享资源的访问 =&gt; 条件变量 =&gt; 利用信号量来通知其它线程状态变化</div></div><div><b><br/></b></div><div><b>生产者-消费者问题</b></div><div><img src="/images/posts/csapp-c12/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>需要处理：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.保证对缓冲区的互斥访问；</div><div>2.调度线程对缓冲区的访问；</div></div><div>mutex：提供互斥的缓冲区访问，互斥锁</div><div>slots：空槽位的可用数目，条件变量</div><div>items：可用项目的数目，条件变量</div><div><img src="/images/posts/csapp-c12/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><b>读者-写者问题</b></div><div>写者必须独占访问，读者可以和其它读者共享对象</div><div>基于读者和写者的优先级，两个变种：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.读者优先，读者不等待，除非已经把权限赋予写者，即读者不会因为一个写者在等待而等待；</div><div>2.写者优先，一旦写者准备写，应尽快完成写操作，在一个写者后到达的读者必须等待，即使这个写者也是在等待；</div></div><div><br/></div><div><br/></div><div><b>9.基于预线程化的并发服务器   prethreading</b></div><div>=&gt; 预先分配工作线程，待任务到达时，调度工作线程执行</div><div><img src="/images/posts/csapp-c12/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><b><br/></b></div><div><b>10.提高并行性 =&gt; 充分利用多核上的线程</b></div><div><b>并行程序是一个运行在多个处理器上的并发程序</b></div><div>提高性能的技巧：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.将任务划分成多个区域，各自分配到不同线程 =&gt; 可能会有巨大的同步开销，应尽量用尽可能多的有用计算弥补这个开销</div><div>2.避免同步开销：让每个对等线程在各自的私有变量中计算（私有变量不共享），最后再汇总</div><div>3.更多优化避免频繁访问内存</div></div><div><br/></div><div><img src="/images/posts/csapp-c12/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>3种方式实现的整数求和，线程数和时间消耗对比：</div><div>=&gt; 频繁的同步导致巨大的开销（差一个时间量级），应该尽可能避免</div><div><img src="/images/posts/csapp-c12/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><hr/><div><b><font style="font-size: 12pt;">刻画并行程序的性能</font></b></div><div>1.加速比 speedup：衡量并行程序在并行性上的利用率</div><div><img src="/images/posts/csapp-c12/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>绝对加速比 absolute speedup：T1使用的是程序顺序执行版本的执行时间</div><div><span>    </span><span>    </span><span>    能更好的衡量并行的好处，但</span>特意制作顺序执行版本的成本可能很高<br/></div><div>相对加速比 relative speedup：T1使用的是程序并行执行版本在一个核上的执行时间</div><div><span>    </span><br/></div><div><span>2.效率 efficiency ：对由于并行化造成开销的衡量</span></div><div><img src="/images/posts/csapp-c12/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div><b><font style="font-size: 12pt;">线程安全</font></b></div><div><b>1.四类线程不安全函数：</b></div><div>a.不保护共享变量的函数</div><div>  =&gt; 利用P/V同步操作保护共享的变量</div><div>b.跨越多个调用的状态的函数</div><div>  =&gt; 依靠调用者在参数中传递状态信息</div><div>c.返回执行静态变量的指针的函数</div><div>  =&gt; 重写函数，改为调用者传递存放结果的变量的地址</div><div>  =&gt; 使用加锁-复制技术，定义一个线程安全的包装函数</div><div>d.调用了线程不安全的函数的函数</div><div>  =&gt; 重写，或者用互斥锁保护调用位置或共享数据</div><div><br/></div><div><b>2.可重入性 reentrant</b></div><div>特征：被多个线程调用时，不会引用任何共享数据</div><div>可重入函数是线程安全函数的一个真子集</div><div><img src="/images/posts/csapp-c12/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>=&gt; <b style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">可重入性既是调用者也是被调用者的属性，并不只是被调用者的属性</b></div><div>      调用者传递的参数如果是指向共享对象的指针，也是不可重入的</div><div><br/></div><div><b>3.常见的线程不安全的库函数</b></div><div><img src="/images/posts/csapp-c12/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><b>4.竞争 race</b></div><div>竞争：一个程序的正确性依赖于两个线程控制流的执行顺序</div><div>=》多线程的程序必须对任何可行的轨迹线都能正确工作</div><div><br/></div><div><b>5.死锁 deadlock</b></div><div>死锁：一组线程被阻塞，等待用于不成立的条件</div><div><img src="/images/posts/csapp-c12/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><b>互斥锁加锁顺序规则</b>：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，</div><div>那么这个程序就是无死锁的</div></div></span>
</div>